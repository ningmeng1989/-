<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>W3Tech 笔记</title>
</head>
<body>

评估局部变量
创建代码快捷方式以加速编码
在将元素片段添加到DOM之前对其实施操作
使用minification保存字节
除非必要，否则不要使用嵌套循环
缓存对象以提高性能
使用.js文件来缓存脚本
将JavaScript放置到页面的底部
使用jQuery作为框架
使用Gzip压缩文件
不要使用With关键字
尽量减少对HTTP的请求
实现事件代理
不要重复使用相同的脚本
移除双美元符号$$
创建变量引用
提高Object Detection的速度
编写有效的循环
缩短作用域链
对NodeLists直接索引
不要使用eval
使用函数内联
实现Common Sub-expression Elimination
离线构建DOM节点以及所有子节点
尽量不要使用全局变量
使用原始的函数操作而不使用函数调用
不要一直保留对其他文档的引用
使用XMLHttpRequest
避免使用try catch finally 结构
不要误用 for in

call比apply快


单例模式

构造函数模式

建造者模式-在软件系统中，有时候面临着 一个复杂对象的 创建工作，建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示，也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了
建造者模式主要用于 分步骤 构建一个复杂对象，在这其中 分步骤 是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是，建造者模式的 加工工艺 是暴露的，这样建造者模式解耦了组装工程和创建具体部件，使得我们不用去关心每个部件是如何组装的

工厂模式-工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类，该模式使一个类的实例延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型。需要定义工厂类和相应的子类。以下几种情景下工厂模式特别有用：对象的构建十分复杂，需要依赖具体环境创建不同实例，处理大量具有相同属性的小对象

装饰者模式-装饰者提供比继承更有弹性的替代方案，装饰者用于包装同接口的对象，不仅允许你想方法添加行为，而且还可以将方法设置成原始对象调用，装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。优点是把类的核心职责和装饰功能区分开了。

外观模式-为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。
在设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观facade
在开发阶段，子系统往往因为不断地重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖
最后，在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。

代理模式-为其他对象提供一种代理以控制对这个对象的访问













































































































</body>
</html>