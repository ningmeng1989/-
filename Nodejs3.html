<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NodeJS</title>
</head>
<body>

Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常好

使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。

Node.js应用由哪几部分组成：
引入required模块
创建服务器
接收请求与响应请求

NPM常见的使用场景：
从NPM服务器下载别人编写的第三方包到本地使用
从NPM服务器下载并安装别人编写的命令行程序到本地使用
将自己编写的包或命令行程序上传到NPM服务器供别人使用

REPL(Read Eval Print Loop)--交互式解释器

Node.js事件循环

Node.js是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高
Node.js的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发
Node.js基本上所有的事件机制都是用设计模式中观察者模式实现
Node.js单线程类似进入一个while的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数

在Node应用程序中，执行异步操作的函数将回调函数作为最后一个参数，回调函数接收错误对象作为第一个参数

Node.js所有的异步I/O操作在完成时都会发送一个事件到事件队列
Node.js里面的许多对象都会分发事件，一个net.Server对象会在每次有新连接时分发一个事件，一个fs.readStream对象会在文件被打开的时候发出一个事件，所有这些产生事件的对象都是events.EventEmitter的实例

events模块只提供了一个对象，events.EventEmitter。EventEmitter的核心就是事件触发和事件监听功能的封装

var EventEmitter = require('events').EventEmitter;
var event = new EventEmitter();
event.on('some_event', function() {})
setTimeout(function() {
    event.emit('some_event');
}, 1000)

对每个事件，EventEmitter支持若干个事件监听器
当事件触发，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递

addListener(event, listener)--为指定事件添加一个监听器到监听器数组的尾部
on(event, listener)--为指定事件注册一个监听器，接收一个字符串event和一个回调函数
once(event, listener)--为指定事件注册一个单次监听器
removeListener(event, listener)--移除指定事件的某个监听器
removeAllListener([event])
setMaxListeners(n)--默认情况下，EventEmitter如果你你添加的监听器超过10个就会输出警告信息，setMaxListeners函数用于提高监听器的默认限制的数量
listeners(event)--返回指定事件的监听器函数
emit(event, arg1, arg2)

listenerCount(emitter, event)--返回指定事件的监听器数量

newListener--
removeListener

EventEmitter定义了一个特殊的事件error，它包含了错误的语义，我们在遇到异常的时候通常会触发error事件，当error被触发时，EventEmitter规定如果没有响应的监听器，Node.js会把它当做异常，退出程序并输出错误信息，我们一般要为触发error事件的对象设置监听器，避免遇到错误后整个程序崩溃。

大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs、net、http在内的，只要是支持事件响应的核心模块都是EventEmitter的子类
--具有某个实体功能的对象实现事件符合语义，事件的监听和发生应该是一个对象的方法
--JavaScript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系

Buffer用来创建一个专门存放二进制数据的缓存区
Node.js目前支持的字符编码包括：
ascii utf8 utf16le ucs2 base64 latin1 binary hex

创建Buffer类
Buffer.alloc(size, fill, encoding)--
Buffer.allocUnsafe(size)
Buffer.allocUnsafeSlow(size)
Buffer.from(array)--传入的array的元素只能是数字，不然会自动被0覆盖
Buffer.from(arrayBuffer, byteOffset, length)--返回一个新建的与给定的ArrayBuffer共享同一内存的Buffer
Buffer.from(buffer)
Buffer.from(string, encoding)

写入缓冲区
buf.write(string, offset, length, encoding)
string--写入缓冲区的字符串
offset--缓冲区开始写入的索引值
length--写入的字节数
encoding--使用的编码
返回实际写入的大小

buf.toString(encoding, start, end)
encoding--使用的编码
start--指定开始读取的索引位置
end--结束位置，默认为缓冲区的末尾
解码缓冲区数据并使用指定的编码返回字符串

将Buffer转换为JSON对象
buf.toJSON()

缓冲区合并
Buffer.concat(list, totalLength)

缓冲区比较
buf.compare(otherBuffer)
返回一个数字，表示buf在otherBuffer之前，之后或相同

拷贝缓冲区
buf.copy(targetBuffer, targetStart, sourceStart, sourceEnd)

buf.slice(start, end)

buf.length
返回Buffer对象所占据的内存长度

new Buffer(size)
new Buffer(buffer)
new Buffer(str, encoding)
buf.length
buf.write(string, offset, length, encoding)
buf.writeUIntLE(value, offset, byteLength, noAssert)
buf.writeUIntBE(value, offset, byteLength, noAssert)
buf.writeIntLE(value, offset, byteLength, noAssert)
buf.writeIntBE(value, offset, byteLength, noAssert)
buf.readUIntLE(offset, byteLength, noAssert)
buf.readUIntBE(offset, byteLength, noAssert)
buf.readIntLE(offset, byteLength, noAssert)
buf.readIntBE(offset, byteLength, noAssert)
buf.toString(encoding, start, end)
buf.toJSON()
buf[index]
buf.equals(otherBuffer)
buf.compare(otherBuffer)
buf.copy
.slice
.readUInt8
.readUInt16LE
.readUInt16BE
.readUInt32LE
.readUInt32BE
.readInt8
.readInt16LE
.readInt16BE
.readInt32LE
.readInt32BE
.readFloatLE
.readFloatBE
.readDoubleLE
.readDoubleBE
.writeUInt8
.writeUInt16LE
.writeUInt16BE
.writeUInt32LE
.writeUInt32BE
.writeInt8
.writeInt16LE
.writeInt16BE
.writeInt32LE
.writeInt32BE
.writeFloatLE
.writeFloatBE
.writeDoubleLE
.writeDoubleBE
.fill(value, offset, end)

Stream(流)

Node.js，Stream有四种流类型：
Readable
Writable
Duplex--可读可写操作
Transform--操作被写入数据，然后读出结果

所有的Stream对象都是EventEmitter的实例，常用的事件有：
data--当有数据可读时触发
end
error
finish--所有数据已被写入到底层系统时触发

var fs = require('fs')
var data = ''

var readerStream = fs.createReadStream('input.txt')
readerStream.setEncoding('UTF8')

readerStream.on('data', function(chunk) {
    data += chunk;
})

readerStream.on('end', function() {

})

readerStream.on('error', function(err) {

})

var writeStream = fs.createWriteStream('output.txt')
writeStream.write(data, 'UTF8')
writeStream.end()

writeStream.on('finish', function() {
    console.log('写入完成')
})
writeStream.on('error', function(err) {
    console.log(err.stack)
})

管道流
管道提供了一个输出流到输入流的机制，通常我们用于从一个流中获取数据并将数据传递到另外一个流中

var readerStream = fs.createReadStream('input.txt');
var writerStream = fs.createWriteStream('output.txt');

readerStream.pipe(writerStream)

链式流
链式是通过连接输出流到另一个流并创建多个流操作链的机制，链式流一般用于管道操作
如用管道和链式来压缩和解压文件

fs.createReadStream('input.txt')
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream('input.txt.gz'))


fs.createReadStream('input.txt.gz')
    .pipe(zlib.createGunzip())
    .pipe(fs.createWriteStream('input.txt'))

模块系统
一个Node.js文件就是一个模块，这个文件可能是JavaScript代码，JSON或者编译过的C/C++扩展
./ 当前目录
exports--是模块公开的接口
require--从外部获取一个模块的接口

exports.world = function() {}

module.exports = 在外部引用该模块时，其接口对象就是要输出的Hello对象本身，而不是原先的exports

1、从文件模块缓存中加载
2、从原生模块加载
3、从文件加载

http.createServer(function(request, response) {
    response.writeHead(200, {"Content-Type": "text-plain"});
    response.write("Hello World");
    response.end();
}).listen(8888);

Node.js路由

我们要为路由提供请求的URL和其他需要的GET和POST参数，随后路由需要根据这些数据来执行相应的代码
因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数
url queryString

var http = require("http")
var url = require("url")

function start() {
    function onRequest(request, response) {
        var pathname = url.parse(request.url).pathname;
        console.log("Request for " + pathname + " received.");
        response.writeHead(200, {"Content-Type": "text-plain"});
        response.write("Hello World");
        response.end();
    }

}

Node.js中的全局对象是global

global最根本的作用是作为全局变量的宿主
在最外层定义的变量
全局对象的属性
隐式定义的变量

当你定义一个全局变量时，这个变量同时也会成为全局对象的属性。
在Node.js中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文

__filename 表示当前正在执行的脚本的文件名，它将蔬菜文件所在位置的结对路径
/web/nodejs/main.js

__dirname 表示当前执行脚本所在的目录
/web/nodejs

setTimeout
clearTimeout

setInterval

console

console.log()
console.info()
console.error()
console.warn()
console.dir--用来对一个对象进行检查，并以易于阅读和打印的格式显示
console.time(label)
console.timeEnd(label)
console.trace()--当前执行的代码在堆栈中的调用路径
console.assert()

process
用于描述当前Node.js进程状态的对象
exit
beforeExit
uncaughtException
signal

退出状态码：
1--Uncaught Fatal Exception
2--Unused
3--Internal JavaScript Parse Error
4--Internal JavaScript Evaluation Error
5--Fatal Error
6--Non-function Internal Exception Handler
7--Internal Exception Handler Run-Time Failure
9--Invalid Argument
10--Internal JavaScript Run-Time Failure
12--Invalid Debug Argument
128--Signal Exits

属性：
stdout
stderr
stdin
argv
execPath--
execArgv
env
exitCode
version
versions
config
pid
title
arch
platform
mainModule

Process提供的有用的方法：
abort()--
chdir()
cwd()
exit()
getgid()
setgid(id)
getuid()
setuid(id)
getgroups()
setgroups(groups)
initgroups(user, extra_group)
kill(pid, signal)
memoryUsage()
nextTick--一旦当前事件循环结束，调用回调函数
umask()--设置或读取进程文件的掩码
uptime--返回Node已经运行的时间
hrtime--返回当前进程的高分辨时间

Node.js常用工具
util是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的功能过于精简的不足

util.inherits(constructor, superConstructor)

Sub仅仅继承了Base在原型中定义的函数，而构造函数内部创造的base属性和sayHello函数没有被Sub继承

Util.inspect(object, showHidden, depth)

Util.isArray(Object)

Util.isRegExp(object)

Util.isDate(object)

Util.isError(object)

Node.js文件系统

Node.js文件系统模块中的方法都有异步和同步版本
fs.readFile() readFileSync()

异步方法函数的最后一个参数是回调函数，回调函数的第一个参数包含了错误信息
异步方法性能更高，速度更快，而且没有阻塞

fs.readFile('input.txt', function(err, data) {
    if(err) {}
})

var data = fs.readFileSync('input.txt')

fs.open(path, flags, mode, callback)

flags:
r  读取模式
r+  读写模式
rs  同步方式读取
rs+  同步方式读写
w  写入模式，文件不存在则创建
wx  写入，文件不存在则写入失败
w+  读写模式，文件不存在则创建
wx+ 读写模式，文件不存在则写入失败
a  追加模式，文件不存在则创建
ax  追加模式，文件不存在则追加失败
a+  读写追加模式，文件不存在则创建
ax+  读写追加模式，文件不存在则追加失败

fs.open('input.txt', 'r+', function(err, fd) {

})

获取文件信息
fs.stat(path, callback)

stats是fs.Stats对象
isFile()--是文件为true
isDirectory--是目录为true
isBlockDevice--块设备
isCharacterDevice--字符设备
isSymbolicLink--软链接
isFIFO--是UNIX中一种特殊类型的命令管道
isSocket--Socket

dev
mode
nlink
uid
gid
rdev
blksize
ino
size
blocks
atime
mtime
ctime

写入文件
fs.writeFile(file, data, options, callback
)

fs.read(fd, buffer, offset, length, options, callback)

fd--通过fs.open()方法返回的文件描述符
buffer--数据写入的缓冲区
offset--缓冲区写入的写入偏移量
length--要从文件中读取的字节数
position--
callback--err, bytesRead, buffer

fs.close(fd. callback)

fs.ftruncate(fs, len, callback)

fs.unlink(path, callback)

创建目录
fs.mkdir(path, mode, callback)

fs.readdir(path, callback)
回调后一个参数为files，目录下的文件数组列表

fs.rmdir(path, callback)

fs.rename(oldPath, newPath, callback)
fs.ftruncate(fd, len, callback)
fs.ftruncateSync(fd, len)
fs.truncate(path, len, callback)
fs.truncateSync(path, len)
fchown
lchown
chmod
fchmod
lchmod
stat
lstat
fstat
link
symlink
readlink
realpath
unlink
rmdir
mkdir
readdir
close
open
utimes
futimes
fsync
write
read
readFile
write
writeFile
appendFile
watchFile
unwatchFile
exists
access
createReadStream
createWriteStream
symlink

GET/POST请求

util.inspect(url.parse(req.url, true))

url.parse(req.url, true).query

var querystring = require('querystring')

var post = ''
req.on('data', function(chunk) {
    post += chunk;
})
req.on('end', function() {
    post = querystring.parse(post);
    res.end(util.inspect(post))
})

OS模块
os.tmpdir()--操作系统的默认临时文件夹
endianness--返回CPU的字节序，BE LE
hostname--操作系统的主机名
type--操作系统名
platform--操作系统名
arch--操作系统的CPU架构
release--操作系统的发行版本
uptime--操作系统的运行时间
loadavg--返回一个包含1 5 15分钟平均负载的数组
totalmem--系统内存总量
freemem--系统空闲内存量
cpus--返回一个对象数组，包含所安装的每个CPU内核的信息
networkInterfaces--获得网络接口列表

Path模块
path.normalize(p)
path.join(path1, path2)
path.resolve(from, to)--将to参数解析为绝对路径
isAbsolute(path)--是否为绝对路径
relative(from, to)--将相对路径转为绝对路径
dirname(p)--返回路径中代表文件夹的部分
basename(p)--返回路径中最后一部分
extname(p)--返回路劲中文件的后缀名
parse(path String)--返回路径字符串的对象
path.format(pathObject)--从对象中返回路径字符串

path.sep
path.delimiter
path.posix
path.win32

Net模块
提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法

net.createServer(options, connectionListener)
net.connect(options, connectionListener)
net.createConnection(options, connectionListener)
net.connect(port, host, connectionListener)
net.createConnection(port, host, connectListener)
net.connect(path, connectListener)
net.createConnection(path, connectListener)
net.isIP(input)
net.isIPv4(input)
net.isIPv6(input)


server.listen(port, host, backlog, callback)
server.listen(path, callback)
server.listen(handle, callback)
server.listen(options, callback)
server.close(callback)
server.address()--返回绑定的地址，协议族号和服务器端口
server.unref()
server.ref()
server.getConnections(callback)--异步获取服务器当前活跃连接的数量

事件：
listening
connection
close
error

net.Socket 事件
lookup
connect
data
end
timeout
drain--写缓存为空的时候触发
err
close

net.Socket有很多有用的属性
socket.bufferSize
remoteAddress
remoteFamily
remotePort
localAddress
localPort
bytesRead
bytesWritten

net.Socket的方法
new net.Socket(options)
connect(port, host, connectListener)
setEncoding(encoding)
write(data, encoding, callback)
end(data, encoding)
destroy()
pause()
resume
setTimeout(timeout, callback)
setNoDelay()
setKeepAlive(enable, initialDelay)--
address()
unref()
ref()

DNS 模块

dns.lookup(hostname, options, callback)--将域名解析为第一条找到的记录
dns.lookupService(address, port, callback)--使用getnameinfo解析传入的地址和端口为域名和服务
dns.resolve(hostname, rrtype, callback)--将一个域名解析为一个rrtype指定记录类型的数组
dns.resolve4(hostname,callback)--将一个域名解析为一个rrtype指定记录类型的数组，IPV4
dns.resolve6(hostname,callback)--将一个域名解析为一个rrtype指定记录类型的数组，IPV6
dns.resolveMx--仅能查询邮件交换
dns.resolveTxt(hostname, callback)--仅能进行文本查询
dns.resolveSrv(hostname, callback)
dns.resolveSoa(hostname, callback)
dns.resolveNs
dns.resolveCname()
dns.reverse(ip, callback)
dns.getServers()--返回一个用于当前解析的IP地址数组的字符串
dns.setServers(servers)--

rrtypes有效的值：
A
AAAA
MX
TXT
SRV
PTR
NS
CNAME
SOA

dns.NODATA
dns.FORMERR
SERVFAIL
NOTFOUND
NOTIMP
REFUSED
BADQUERY
BADNAME
BADFAMILY
BADRESP
CONNREFUESD
TIMEOUT
EOF
FILE
NOMEM
DESTRUCTION
BADSTR
NONAME
BADHINTS
NOTINITIALIZED
LOADIPHLPAPI
ADDRGETNETWORKPARAMS
CANCELED

Domain 模块

domain模块，把处理多个不同的IO的操作作为一个组，注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出。

domain.run(function)
domain.add(emitter)
domain.remove(emitter)
domain.bind(callback)
domain.intercept(callback)
domain.enter()
domain.exit()
domain.dispose()
domain.creat()

domain.members


Node.js v8.9.0 文档

（一）、assert 断言

断言测试的函数，用于测试不变式

assert(value, message)--assert.ok()的别名

assert.deepEqual(actual, expected, message)
测试actual参数与expected参数是否深度相等，原始值使用==比较
只测试可枚举的自身属性，不测试对象的原型、连接符、或不可枚举的属性
子对象中可枚举的自身属性也会被测试

assert.deepStrictEqual(actual, expected, message)
与assert.deepEqual()大致相同，一些区别：
原始值使用===比较
对象的原型也使用全等运算符比较
对象的类型标签要求相同
如果两个值不相等，则抛出一个带有message属性的AssertionError，其中message属性的值等于传入的message参数的值

assert.doesNotThrow(block, error, message)
断言block函数不会抛出错误
当assert.doseNotThrow()被调用时，它会立即调用block函数
如果抛出错误且错误类型与error参数指定的相同，则抛出AssertionError，如果错误类型不相同，或error参数为undefined，则抛出错误

assert.equal(actual, expected, message)
使用==测试actual参数与expected参数是否相等
如果两个值不相等，则抛出一个带有message属性的AssertionError，其中message属性的值等于传入的message参数的值，如果message参数为undefined，则赋予默认的错误信息

assert.fail(message)
assert.fail(actual, expected, message, operator, stackStartFunction)

assert.ifError(value)
如果value为真，则抛出value，可用于测试回调函数的error参数

assert.notDeepEqual(actual, expected, message)

assert.notDeepStrictEqual(actual, expected, message)

assert.notEqual(actual, expected, message)

assert.notStrictEqual(actual, expected, message)

assert.ok(value, message)

assert.strictEqual(actual, expected, message)

assert.throws(block, error, message)

（二）、Buffer--缓冲器

Buffer.alloc(size, fill, encoding)

Buffer.allocUnsafe(size)

Buffer.allocUnsafeSlow(size)

Buffer.byteLength(string, encoding)

Buffer.compare(buf1, buf2)

Buffer.concat(list, totalLength)

Buffer.from(array)

Buffer.from(arrayBuffer, byteOffset, length)

Buffer.poolSize--用于决定预分配的、内部Buffer实例池的大小的字节数

buf[index]
buf.buffer
buf.compare(target, targetStart, targetEnd, sourceStart, sourceEnd)
buf.copy(target, targetStart, sourceStart, sourceEnd)
buf.entries()
buf.equals(otherBuffer)
buf.fill(value, offset, end, encoding)
buf.includes(value, byteOffset, encoding)
buf.indexOf(value, bodyOffset, encoding)
buf.keys()
buf.lastIndexOf()
buf.length
buf.readDoubleBE(offset, noAssert)
buf.readDoubleLE(offset, noAssert)
buf.readFloatBE(offset, noAssert)
buf.readFloatLE(offset, noAssert)
buf.slice(start, end)
buf.swap16()
buf.toJSON()
buf.toString(encoding, start, end)
buf.values()
buf.write(string, offset, length, encoding)
buf.writeDoubleBE(value, offset, noAssert)
buf.writeDoubleLE(value, offset, noAssert)
buffer.INSPECT_MAX_BYTES
buffer.kMaxLength
buffer.transcode(source, fromEnc, toEnc)
Buffer.constants.MAX_LENGTH
Buffer.constants.MAX_STRING_LENGTH

（三）、child_process--子进程

child_process.exec(command, options, callback)
child_process.execFile(file, args, options, callback)
child_process.fork(modulePath, args, options)
child_process.spawn(command, args, options)
  options.detached
  options.stdio

child_process.execFileSync(file, args, options)
child_process.execSync(command, options)
child_process.spawnSync(command, args, options)

close
disconnect
error
exit
message

subprocess.channel
subprocess.connected
subprocess.disconnect
subprocess.kill
subprocess.killed
subprocess.pid
subprocess.send(message, sendHandle, options, callback)
subprocess.stderr
subprocess.stdin
subprocess.stdout

maxBuffer与Unicode
Shell Requirements
Default Windows Shell

const { spawn } = require('child_process')
const ls = spawn('ls', ['-lh', '/usr'])

ls.stdout.on('data', (data) => { })
ls.stderr.on('data', (data) => { })
ls.on('close', (data) => { })

默认情况下，在Node.js的父进程与衍生的子进程之间会建立stdin, stdout, stderr的管道。数据能以非阻塞的方式在管道中流通，数据能以非阻塞的方式在管道中流通。注意，有些程序会在内部使用行缓冲IO。虽然这并不影响Node.js，但这意味着发送到子进程的数据可能无法被立即使用。
child_process.spawn()方法会异步地衍生子进程，且不会阻塞Node.js事件循环。child_process.spawnSync()方法则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或终止。
child_process.exec()--衍生一个shell并在shell上运行命令，当完成时传入stdout和stderr到回调函数
child_process.execFile()--类似child_process.exec()，但直接衍生命令，且无需先衍生一个shell
child_process.fork()--衍生一个新的Node.js进程，并通过建立一个IPC通讯通道来调用一个指定的模块，该通道运行父进程与子进程之间相互发送信息
child_process.execSync()--child_process.exec()的同步方法，会阻塞Node.js事件循环
child_process.execFileSync()--child_process.execFile()的同步方法，会阻塞Node.js事件循环
对于某些用例，如自动化的shell脚本，同步的方法可能更方便，大多数情况下，同步的方法会明显影响性能，因为它会拖延事件循环知道衍生进程完成。

这些方法都会返回一个ChildProcess实例，这些对象实现了Node.js EventEmitter的API，允许父进程注册监听器函数，在子进程声明周期期间，当特定的时间发生时会调用这些函数。exec和execFile返回可以额外指定一个可选的callback函数，当子进程结束时会被调用。

在Windows上衍生.bat和.cmd文件

child_process.exec()和child_process.execFile()之间的重大区别会根据平台的不同而不同，在类Unix操作系统上(Unix\Linux\macOS)，child_process.execFile()效率更高，因为它不需要衍生一个shell。但是在Windows上，.bat和.cmd文件在没有终端的情况下是不可执行的，因此不能使用child_process.execFile()启动。在Windows下运行时，要调用.bat和.cmd文件，可以通过使用设置了shell选项的child_process.spawn()或使用child_process.exec()、或衍生cmd.exe并将.bat或.cmd文件作为一个参数传入（也就是shell选项和child_process.exec()所做的工作）。在任何情况下，如果脚本文件名包含了空格，则需要加上引号。

const { spawn } = require('child_process')
const bat = spawn('cmd.exe', ['/c', 'my.bat']);

bat.stdout.on('data', (data) => {
})

bat.stderr.on('data', (data) => {
})

bat.on('exit', (code) => {
})

const { exec } = require('child_process')
exec('my.bat', (err, stdout, stderr) => {
    if (err) {
        console.error(err);
        return ;
    }
    console.log(stdout);
});

const bat = spawn('"my script.cmd"', ['a', 'b'], { shell: true });

exec('"my script.cmd" a b', (err, stdout, stderr) => {
})

child_process.exec(command, options, callback)

command: 要运行的命令，用空格分隔参数
options：
cwd-string-子进程的当前工作目录
env-object-环境变量键值对
encoding-utf8
shell-string-用于执行命令的shell，在Unix上默认为'/bin/sh'，在Windows上默认为process.env.Comspec
maxBuffer-stdout或stderr允许的最大字节数，默认为200*1024，如果超过限制，则子进程会被终止
killSignal-string-integer--默认为SIGTERM
uid-设置该进程的用户标识
gid-设置该进程的组标识
windowsHide-hide the subprocess console window that would normally be created on Windows systems

error
stdout
stderr

衍生一个shell，然后在 shell中执行command，且缓冲任何产生的输出，传入exec函数的command字符串会被shell直接处理，特殊字符需要相应处理。

exec('"/path/to/test file/test.sh" args1 arg2');
exec('echo "The \\$HOME variable is $HOME"');

不要把未经检查的用户输入传入到该函数，任何包括shell元字符的输入都可被用于触发任何命令的执行

child_process.execFile(file, args, options, callback)
类似exec，除了不衍生一个shell，而是指定的可执行的file被直接衍生为一个新进程，更高效

child_process.fork(modulePath, args, options)

modulePath-string-要在子进程中运行的模块
fork()方法是spawn的一个特殊情况，专门用于衍生新的node.js进程
衍生的Nodejs子进程与两者之间建立的IPC通信信道的异常是独立于父进程的。每个进程都有自己的内存，使用自己的V8实例

默认情况下，child_process.fork()会使用父进程中的process.execPath衍生新的Node.js实例。options对象中的execPath属性可以替换要使用的执行路径

使用自定义的execPath启动的Node.js进程，会使用子进程的环境变量NODE_CHANNEL_FD中指定的文件描述符与父进程通信，fd上的输入和输出被分割成一行一行的JSON对象

child_process.spawn(command, args, options)

在Windows上，detached-true可以使子进程在父进程退出后继续运行
在非Window上，则子进程会成为新的进程组和会话的领导者
subprocess.unref,这样会导致父进程的事件循环不包含子进程的引用计数

options.stdio
pipe
ignore
inherit

当在父进程和子进程之间建立了一个IPC通道，且子进程是一个Node.js进程，则子进程会带着未引用的IPC通道启动，直到子进程为process.on('disconnect')或message事件注册了一个事件句柄。这使得子进程可以再进程没有通过打开的IPC通道保持打开的情况下正常退出。

child_process spawnSync execSync execFileSync 方法是同步的且会阻塞Node.js的事件循环，暂停任何额外代码的执行直到衍生的进程退出
像这样的阻塞调用有利于简化普通用途的脚本任务，且启动时有利于简化应用配置的加载/处理

execSync--当遇到超时且发送了killSignal时，该方法直到进程完全退出后才返回结果

ChildProcess类的实例是EventEmitter，代表衍生的子进程
ChildProcess的实例不被直接创建，

close事件--
code 如果子进程退出自身，则该值是退出码
signal 子进程被终止时的信号
当子进程的stdio流被关闭时会触发close事件

disconnect事件
在父进程调用subprocess.disconnect或子进程中调用process.disconnect()后会触发'disconnect'事件，断开后就不再发送或接受信息

error事件
进程无法被衍生
进程无法被杀死
向子进程发送信息失败

exit事件
子进程结束后会触发exit事件
exit事件被触发时，子进程的stdio流可能依然是打开的

message事件
当一个子进程使用process.send()发送消息时会触发message事件

subprocess.channel
--当前子进程的IPC通道的引用
subprocess.connected
--是否仍可以从一个子进程发送和接受消息
subprocess.disconnect
关闭父进程和子进程之间的IPC通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出
subprocess.kill(signal)
subprocess.killed
subprocess.pid
subprocess.send(message, sendHandle, options, callback)

（四）、cluster--集群

cluster模块允许简单容易的创建共享服务器端口的子进程
在Windows中，还不能在工作进程中设置管道服务器

Worker对象包含了关于工作进程的所有public信息和方法

（五）、console类

new Console(stdout, stderr)
console模块提供了一个简单的调试控制台，类似于Web浏览器提供的JavaScript控制台
一个Console类，包含console.log() console.error() console.warn()，可以被用于写入到任何Node.js流。
一个全局的Console实例，可被用于写入到process.stdout和process.stderr。全局的console使用时无需调用require('console')

全局的console对象的方法既不总是同步的，也不总是异步的

const myConsole = new console.Console(out, err)

myConsole.log()

console类可用于创建一个具有可配置的输出流的简单记录器。

new Console(stdout, stderr)
通过传入一个或两个可写流的实例，创建一个新的Console对象，stdout是一个可写流，用于打印日志或输出信息，stderr用于输出警告或错误，如果没有传入stderr，则警告或错误输出会被发送到stdout

console.assert(value, message, args)

console.clear()

console.count(label)
维护一个指定label的内部计数器并且输出到stdout指定label调用console.count()的次数

console.countReset(label)
重置指定label的内部计数器

console.dir(obj, options)
obj
options-showHidden depth colors
在obj上使用util.inspect()并打印结果字符串到stdout，该函数会绕过任何定义在obj上的自定义的inspect()函数，可选的options对象可以传入用于改变被格式化的字符串

console.error(data, args)

console.group(label)

console.groupCollapsed()

console.groupEnd()

console.info(data, args)

console.log()

console.time(label)
console.timeEnd(label)

console.trace(message, ...args)

console.warn(data, ...args)

（六）、crypto

crypto模块提供了加密功能，包含对OpenSSL的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装。

const hash = crypto.createHmac('sha256', 'abcdefg').update('I love cupcakes').digest('hex')

try {
    crypto = require('crypto')
} catch (err) {
    console.log('不支持 crypto !')
}

new crypto.Certificate()

certificate.exportChallenge(spkac)--返回spkac数据结构的challenge部分

certificate.exportPublicKey(spkac)--返回spkac数据机构的公匙部分

certificate.verifySpkac(spkac)--spkac数据结构是否有效

Cipher
cipher类的实例用于加密数据，这个类可以用在用在以下两种方法中的一种

cipher.write()
cipher.update()
cipher.final(outputEncoding)
返回任何加密的内容
cipher.setAAD(buffer)
当使用经过验证的加密模式时，cipher.setAAD()方法设置用于additional authenticated data输入参数的值
cipher.getAuthTag()
cipher.setAutoPadding()
cipher.update(data, inputEncoding, outputEncoding)

Decipher
Decipher的实例用于解密数据，这个类可以

DiffieHellman

diffieHellman.computeSectet(otherPublicKey, inputEncoding, outputEncoding)
diffieHellman.generateKeys(encoding)
diffieHellman.getGenerator(encoding)
diffieHellman.getPrime(encoding)
diffieHellman.getPrivateKey(encoding)
diffieHellman.getPublicKey(encoding)
diffieHellman.verifyError

Elliptic Curve Diffie-Hellman
椭圆曲线Diffie-Hellman
ECDH

Hash类用于创建数据哈希值的工具类
crypto.createHash('sha256')

Hmac类是用来创建Hmac摘要的工具

Sign

Verify()
Verify类是验证签名的工具

crypto.constants
crypto.DEFAULT_ENCODING
crypto.fips
crypto.createCipher(algorithm, password, options)
crypto.privateDecrypt(privateKey, buffer)
crypto.privateEncrypt(privateKey, buffer)

（七）、dgram-数据报

dgram模块提供了UDP数据包socket的实现

dgram.Socket对象是一个封装了数据包函数功能的EventEmitter

close
error
listening
message

socket.addMembership(multicastAddress, multicastInterface)
通知内核将multicastAddress和multicastInterface提供的多路传送集合通过IP_ADD_MEMBERSHIP这个socket选项结合起来。若multicastInterface参数未指定，操作系统将会选择一个接口并向其添加成员，可以在每个接口上调用一次addMembership方法。

socket.address()-返回一个包含socket地址信息的对象，对于UDP socket，该对象将包含address,family和port属性

socket.bind(port, address, callback)

socket.close(callback)
socket.dropMembership(multicastAddress, multicastInterface)
socket.getRecvBufferSize()
socket.getSendBufferSize()

socket.ref()
socket.send(msg, offset, length, port, address, callback)

socket.setBroadcast(flag)

socket.setMulticastInterface(multicastInterface)

const socket = dgram.createSocket('udp6')

dgram.createSocket(options, callback)
dgram.createSocket(type, callback)

（八）、dns-域名服务器

1、使用底层操作系统工具进行域名解析
2、连接到一个真实的DNS服务器进行域名解析，且始终使用网络进行DNS查询

const { Resolver } = require('dns')
const resolver = new Resolver()
resolver.setServers(['4.4.4.4'])

resolver.resolve4('example.org', (err, address) => {})

getServers
setServers
resolve
resolve4
resolve6
resolveAny
resolveCname
resolveMx
resolveNaptr
resolveNs
resolvePtr
resolveSoa
resolveSrv
resolveTxt
reverse

（九）、Error-异常

Node.js中的运行的应用程序一般会遇到以下四种错误：
标准JavaScript错误
--EvalError SyntaxError RangeError ReferenceError TypeError URIError
由底层操作系统触发的系统错误，例如试图打开一个不存在的文件，试图通过一个已关闭的socker发送数据等
由应用程序代码触发的用户自定义错误
断言错误是错误的一个特殊类别，每当Node.js检测到一个不应该发生的异常逻辑时触发，这类错误通常由assert模块引起

Error.captureStackTracee(targetObject, constructorOpt)

Error.stackTraceLimit
error.code
error.message
error.stack
帧只由JavaScript函数产生
位置信息会是其中之一
native
plain-filename.js:line:column

AssertionError
RangeError
ReferenceError
SyntaxError--在创建他们的上下文是不可恢复的，他们只可被其他上下文捕获
TypeError--表示提供的参数不是一个被允许的类型

（十）、Event-事件

当一个普通的监听器函数被EventEmitter调用时，标准的this关键字会被设置指向监听器所附加的EventEmitter
使用ES6的箭头函数作为监听器，this关键词就不再指向EventEmitter实例

安装监听器注册的书序同步地调用监听器

setImmediate()
process.nextTick()

once

当EventEmitter实例中发生错误时，为了防止Node.js进程崩溃，可以在process对象的uncaughtException事件上注册监听器，或使用domain模块
最好为error事件注册监听器

newListener
removeListener

EventEmitter.defaultMaxListeners

emitter.addListener(eventName, listener)
emitter.emit(eventName, ...args)

emitter.eventNames()

emitter.getMaxListeners()

emitter.listenerCount(eventName)

emitter.listeners(eventName)

.on 添加到监听器数组的末尾

.once

.prependListener(eventName, listener)

.prependOnceListener(eventName, listener)

.removeAllListeners(eventName)

.removeListener(eventName, callback)

.setMaxListeners(n)

（十一）、fs-文件系统

文件I/O是对标准POSIX函数的简单封装

当使用同步方法时，任何异常都会被立即都会被立即抛出。

在所有的文件系统API中，除了fs.FSWatcher()和那些显式同步之外都可以使用libuv的线程池

WHATWG URL Object support

fs.FSWatcher
change-eventType filename
error-
watcher.close()

fs.ReadStream
close
open
readStream.bytesRead
readStream.path

fs.Stats
stats.isFile
stats.isDirectory
stats.isBlockDevice
stats.isCharacterDevice
stats.isSymbolicLink()
stats.isFIFO
stats.isSocket()

Stats:
dev
ino
mode
nlink
uid
gid
rdev
size
blksize
blocks
atimeMs
mtimeMs
ctimeMs
birthtimeMs
atime
mtime
ctime
birthtime

atime--访问时间-文件数据最近被访问的时间 会被mknod utimes read系统调用改变
mtime--修改时间-文件数据最近被修改的时间 会被mknod utimes write系统调用改变
ctime--变化时间-文件状态最近更改的时间 会被chmod chown link mknod rename unlink utimes read write系统调用改变
birthtime--创建时间-

fs.WriteStream
close事件
open事件
writeStream.bytesWritten
writeStream.path

fs.access(path, mode, callback)

fs.constants.F_OK 可见
fs.constants.R_OK 可读
fs.constants.W_OK 可写
fs.constants.X_OK 可执行

建议用户直接打开 读取 写入文件，当文件无法访问时再处理错误

fs.accessSync(path, mode)

fs.appendFile(file, data, options, callback)
异步地追加数据到一个文件，如果文件不存在则创建文件

fs.appendFileSync(file, data, options)

fs.chmod(path, mode, callback)
改变文件读写权限

fs.chown(path, uid, gid, callback)
改变文件所有权

fs.close()

fs.constants
返回一个包含常用文件系统操作的常量的对象

fs.copyFile(src, dest, flags, callback)

fs.copyFileSync(scr, dest, flags)

fs.createReadStream(path, options)

fs.createWriteStream(path, options)

fs.exists(path)

fs.fchmod(fd, mode, callback)

fs.fchown(fd, uid, gid, callback)

fs.fdatasync(fd, callback)--刷新数据到磁盘

fs.fstat(fd, callback)--返回文件的详细信息

fs.fsync(fd, callback)--同步缓存数据到磁盘

fs.ftruncate(fd, len, callback)

fs.futimes(fd, atime, mtime, callback)
改变由所提供的文件描述符所指向的对象的文件系统时间戳

fs.lchmod(path,mode,callback)

fs.link(existingPath, newPath, callback)

fs.lstat(path, callback)

fs.mkdir

fs.readdir(path, options, callback)

fs.readFile(path, options, callback)

fs.readlink(path, options, callback)

fs.readSync(fd, buffer, offset, length, position)

fs.realPath(path, options, callback)

fs.rename(oldPath, newPath, callback)

fs.rmdir(path, callback)

fs.stat(path, callback)

fs.symlink(target, path, type, callback)

fs.truncate(path, len, callback)

fs.unlink(path, callback)

fs.unwatchFile(filename, listener)

fs.utimes(path, atime, mtime, callback)

fs.watch(filename, options, listener)

fs.watchFile(filename, options, listener)

fs.write(fd, buffer, offset, length, position, callback)

fs.writeFile(file, data, options, callback)

（十二）、global-全局变量

全局变量在所有模块中均可使用，但以下变量的作用域只在模块内
__dirname
__filename
exports
module
require()

（十三）、http

Node.js中的HTTP接口被设计成支持协议的许多特性，它把消息解析成消息头和消息主题，但不解析具体的消息头和消息主题

Agent负责为HTTP客户端管理连接的持续与复用，它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的socket连接直到队列为空

http.get(options, (res) => {

}).on('socket', (socket) => {

})

agent: false
则会为客户端连接创建一个默认配置的一次性使用的Agent

new Agent(options)
options:
keepAlive
keepAliveMsecs
maxSockets
maxFreeSockets

const keepAliveAgent = new http.Agent({keep:true})
options.agent = keepAliveAgent

agent.createConnection(options, callback)
agent.keepSocketAlive(socket)
agent.reuseSocket(socket, request)
agent.destroy()
agent.freeSockets()
agent.getName(options)
agent.maxFreeSockets
agent.maxSockets
agent.requests
agent.sockets

http.ClientRequest类被http.request()内部创建并返回，它表示一个正在处理的请求，其请求已进入队列，请求头仍可使用setHeader(name, value)，getHeader(name)和removeHeader(name)API进行修改。实际的请求头会与第一个数据块一起发送或当调用request.end()时发送。
要获取响应，需为'response'事件添加一个监听器到请求对象上，当响应头被接收时，'response'事件会从请求对象上被触发，此事件被执行时带有一个参数，该参数是一个http.IncomingMessage实例。此事件期间，可以添加监听器到响应对象上，比如监听'data'事件
如果没有添加'response'事件处理函数，则响应会被整个丢弃。如果添加了response事件处理函数，则必须消耗完对象的数据，可通过调用response.read() 或添加一个'data'事件处理函数、或调用.resume()方法。数据被消耗完时会触发'end'事件。在数据被读取完之前会消耗内存，可能会造成'process out of memory'错误
Node.js不会检查Content-Length与已传输的请求主体的长度是否相等
abort
connect--每当服务器响应connect请求时触发，如果该事件未被监听，则接收到CONNECT方法的客户端会关闭连接
continue--当服务器发送一个100 Continue的HTTP响应时触发
response--当请求的响应被接受时触发
socket--当socket被分配到请求后触发
timeout--当底层socket超时的时候触发，该方法只会通知空闲的Socket，请求必须手动停止
upgrade--每当服务器响应upgrade请求时触发，如果该事件未被监听，则接收到upgrade请求头的客户端会关闭连接

request.abort()--标记请求为终止，调用该方法将使响应中的剩余的数据被丢弃且socket被销毁
request.aborted--如果请求已被终止，则该属性的值为请求被终止的时间
request.connection
request.end(data, encoding, callback)
request.flushHeaders()
request.getHeader(name)
request.removeHeader(name)
request.setHeader(name, value)
request.setNoDelay(boolean)
request.setSocketKeepAlive(enable, initialDelay)
request.setTimeout(timeout, callback)
request.socket
request.write(chunk, encoding, callback)

http.Server类

checkContinue
checkExpectation
clientError
close
connect
connection
request
upgrade

server.close(callback)
server.listen()
server.listening--表示服务器是否正在监听连接
server.maxHeadersCount--现在请求头的最大数量
server.setTimeout(msecs, callback)
server.timeout
server.keepAliveTimeout--服务器完成最后的响应之后需要等待的额外的传入数据的活跃毫秒数，socket才能被销毁

http.ServerResponse

该对象在HTTP服务器内部被创建，它作为第二个参数被传入request事件
这个类实现了可写流的接口
close--当底层连接在response.end()被调用或能够刷新之前被终止时触发
finish--当响应已被发送时触发，更具体地说，当响应头和响应主体的最后一部分已被交给操作系统通过网络进行传输时，触发该事件

response.addTrailers(headers)
该方法会添加HTTP尾部响应头到响应
仅当响应使用分块编码时，尾部响应头才会被发送，否则，尾部响应头会被丢弃
注意，发送尾部响应头之前，需要先发送Trailer响应头，并在值里带上尾部响应头字段的列表
response.writeHead(200, {
    'Content-Type': 'text/plain',
    'Trailer': 'Content-MD5'
});
response.write(fileData);
response.addTrailers({
    'Content-Type': '7895bf4b8828b55ceaf4747b4bca667'
})
response.end()

response.connection
response.end(data, encoding, callback)
该方法会通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成，每次响应都必须调用response.end()方法
response.finished--表示响应是否已完成
response.getHeader(name)
response.getHeaderNames()
response.getHeaders()
response.hasHeader(name)
response.headersSent
response.removeHeader(name)
response.sendDate
response.setHeader(name, value)
response.setTimeout(msecs, callback)
response.socket
response.statusCode
response.statusMessage
response.write(chunk, encoding, callback)
response.writeContinue()
response.writeHead(statusCode, statusMessage, headers)

http.IncomingMessage

aborted
close

message.destroy(error)
message.headers
message.httpVersion
message.method
message.rawHeaders
message.rawTrailers
message.setTimeout(msecs, callback)
message.socket
message.statusCode
message.statusMessage
message.trailers
message.url

http.METHODS
http.STATUS_CODES
http.createServer(requestListener)
http.get(options, callback)
http.globalAgent
http.request(options, callback)
options--
protocol
host
hostname
family
port
localAddress
socketPath
method
path
headers
auth
agent
createConnection
timeout

（十四）、https

（十五）、module（模块）

Node.js有一个简单的模块加载系统，在Node.js中，文件和模块是一一对应的（每个文件被视为一个独立的模块）

通过在特殊的exports对象上指定额外的属性，函数和对象可以被添加到模块的根部
模块内的本地变量是私有的，因为模块被Node.js包装在一个函数中
module.exports属性可以被赋予一个新的值
赋值给exports不会修改模块，必须使用module.exports

在Node.js直接运行一个文件时，require.main会被设为它的module。这意味着可以通过require.main === module来判断一个文件时是否被直接运行
module提供了一个filename属性，可以通过检查require.main.filename来获取当前应用程序的入口点

Node.js的require()函数的语义被设计得足够通用化，可以支持许多合理的目录结构。包管理器程序可以不用修改就能够从Node.js模块构建本地包

require.resolve()

缓存
模块在第一次加载后会被缓存，这也意味着如果每次调用require('foo')都解析到同一文件，则返回相同的对象
多次调用require(foo)不会导致模块的代码被执行多次，借助它，可以返回“部分完成”的对象，从而允许加载依赖的依赖，即使它们会导致循环依赖
如果想要多次执行一个模块，可以导出一个函数，任何调用该函数

模块缓存的注意事项：
模块是基于其解析的文件名进行缓存的，由于调用模块的位置不同，模块可能被解析成不同的文件名，这样就不能保证require('foo')总能返回完全相同的对象
此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，但缓存仍然会将他们视为不同的模块，并多次重新加载

核心模块 在Node.js源代码的lib/目录下，require总是会优先加载核心模块

文件模块

目录作为模块：
main
index.js
index.node

从全局目录加载
如果NODE_PATH环境变量被设为一个以冒号分割的绝对路径列表，则当在其他地方找不到模块时Node.js会搜索这些路径

强烈建议将所有的依赖放在本地的node_modules目录，这样将会更快的加载，且更可靠

模块包装器
(function(exports, require, module, __filename, __dirname) {

})
这样保持了顶层的变量作用在模块范围内，而不是全局对象
这样有助于提供一些看似全局的但实际上是模块特定的变量，
例如 module exports对象
__dirname __filename 绝对文件名和目录路径

__dirname 当前模块的文件夹名称 path.dirname()
__filename 当前模块的文件名称--解析后的绝对路径
在主程序中这不一定要跟命令行中使用的名称一致

exports--module.exports的简写
module

require()
require.cache
被引入的模块将被缓存在这个对象中，从此对象中删除键值对将会导致下一次require重新加载被删除的模块

require.resolve(request, options)

require.resolve.paths(request)

module对象
在每个模块中，module的自由变量是一个指向表示当前模块的对象的引用，

module.children
被该模块引用的模块对象

module.exports
对module.exports的赋值必须立即完成，不能再任何回调中完成

exports
在模块被执行前被赋予module.exports的值
注意就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到module.exports

function require() {
  const module = { exports: {} }
  ((module, exports) => {

  })(module, module.exports)
  return module.exports
}

module.filename
模块的完全解析后的文件名

module.id

module.loaded
模块是否已经加载完成，或正在加载中
module.parent
最先引用该模块的模块
module.paths
模块的搜索路径
module.require(id)
module.require方法提供了一种类似require()从原始模块被调用的加载模块的方式

（十六）、net（网络）

net模块提供了创建基于流的TCP或IPC服务器（net.createServer()）和客户端（net.createConnection()）的异步网络API

const net = require("net")

IPC Support
net模块在Windows上支持命名管道IPC，在其他操作系统上支持UNIX域套接字

Identifying paths for IPC connections
net.connect() net.createConnection() server.listen() socket.connect()使用一个path参数来识别IPC断点

net.Server类

new net.Server(options, connectionListener)

close事件
connection
error事件
listening事件

server.address()
如果在IP Socket上监听，则返回绑定的ip地址，地址族和操作系统报告的服务端口
只有到了 listening 事件被触发时候，才可以调用server.address()

server.close(callback)

server.getConnections(callback)
异步获取服务器的当前并发连接数

server.listen()
为connections启动一个server监听，一个net.Server可以是一个TCP或者一个IPC Server，这取决于它监听什么
server.listen(handle, backlog, callback)
server.listen(options, callback)
server.listen(path, backlog, callback)
server.listen(port, host, backlog, callback)

server.listen()方法可能会被调用多次，每个后续的调用都将使用其提供的选项重新打开服务器

server.listening
server.maxConnections
server.ref()
server.unref()

net.Socket类
new net.Socket(options)
options--fd allowHalfOpen readable writable

close
connect
data
drain--当写入缓冲区变为空时触发
end
error
lookup--在找到主机之后创建连接之前触发
timeout--当socket超时的时候触发
socket.address()
socket.bufferSize
socket.bytesRead
socket.bytesWritten
socket.connect()
socket.connect(options, connectListener)
socket.connect(path, connectListener)
socket.connect(port, host, connectListener)
该方法是异步的，当连接建立了的时候，connect事件将会触发，如果连接过程中有问题，error事件将会代替connect事件被触发，并将错误信息传递给error监听器，最后一个参数connectListener，如果指定了，将会被添加为connect事件的

options
--port host localAddress localPort family hints lookup
--path

socket.connecting
--connect()被调用但还未结束

socket.destroy(exception)

socket.destroyed
连接是否已经被销毁

socket.end(data, encoding)

socket.localAddress

socket.localPort

socket.pause()
暂定读写数据
socket.ref()

socket.remoteAddress

socket.remoteFamily

socket.remotePort

socket.resume()
在调用socket.pause()之后恢复读取数据

socket.setEncoding(encoding)

socket.setKeepAlive(enable, initialDelay)

socket.setNoDelay(noDelay)

socket.setTimeout(timeout, callback)

socket.unref()

socket.write(data, encoding, callback)

net.connect()

net.createConnection(options, connectListener)

net.createServer(options, connectionListener)

net.isIP(input)
net.isIPv4(input)
net.isIPv6(input)

（十七）、os（操作系统）

const os = require('os');

os.EOL
一个字符串常量，定义操作系统相关的行末标志

os.arch()
Node.js二进制编译所用的操作系统的CPU架构
arm arm64 ia32 mips mipsel ppc ppc64 s390 s390x x32 x64 x86

os.constants
返回一个包含错误码，处理信号等通用的操作系统特定常量的对象

os.cpus()
返回一个对象数组，包含每个逻辑CPU内核的信息

model
speed
times--user nice sys idle irq

os.endianness()
Node.js二进制编译环境的字节顺序
BE--大端模式
LE--小端模式

os.freemem()
空闲系统内存的字节数

os.homedir()
当前用户的home目录

os.hostname()
操作系统的主机名

os.loadavg()
返回一个数组，包含1 5 15分钟平均负载

os.networkInterfaces()
返回一个对象，包含只有被赋予网络地址的网络接口

address
netmask
family
mac
internal
scopeid
cidr

os.platform()
aix
darwim
freebsd
linux
openbsd
sunos
win32

os.release()
操作系统的发行版

os.tmpdir()
操作系统的默认临时文件目录

os.totalmem()
所有系统内存的字节数

os.type()
Linux
Darwim
Windows_NT

os.uptime()
操作系统的上线时间

os.userInfo(options)

os.constants.signals

os.constants.errno

（十八）、path（路径）

path模块提供了一些工具函数，用来处理文件和目录的路径

windows posix

path.win32.basename()
path.posix

path.basename(path, ext)
返回一个path的最后一部分

path.delimiter
提供平台特定的路径分隔符
;
:

path.env.PATH

path.dirname(path)
返回一个path的目录名

path.extname(path)

path.format(pathObject)
pathObject--dir root base name ext

path.isAbsolute(path)
判定path是否为一个绝对路径

path.join([...paths])
使用特定的分隔符把全部给定的path片段连接到一起，并规范化生成的路径

path.normalize(path)

path.parse(path)
dir
root
base
name
ext

path.posix
提供了path方法针对POSIX的实现

path.relative(from,to)

path.resolve([...paths])
一个路径或路径片段的序列 解析为 一个绝对路径

path.sep
平台特定的路径片段分隔符

path.win32
提供了path方法针对Windows的实现

（十九）、process（进程）

beforeExit
disconnect
exit
message
rejectionHandled
uncaughtException
warning

process对象是一个global（全局变量），提供有关信息，控制当前Node.js进程。作为一个对象，它对于Node.js应用程序始终是可用的，故无需使用require()

beforeExit--
当Node.js的事件循环数组已经已经为空，并且没有额外的工作的被添加进来，事件'beforeExit'会被触发。正常情况下，如果没有额外的工作被添加到事件循环数组，Node.js进程会结束。但是如果'beforeExit'事件绑定的监听器的回调函数中，含有一个可以进行异步调用的的操作，那么Node.js进程会继续运行。

procese.exitCode作为唯一的参数值传递给'beforeExit'事件监听器的回调函数

如果进程由于显示的原因而将要终止，例如直接调用process.exit()或抛出未捕获的异常，'beforeExit'事件不会被触发

除非本意就是需要添加额外的工作到事件循环数组，否则不应该用 beforeExit 事件代替 exit 事件

disconnect--
如果Node.js进程时由IPC channel的方式创建的，当IPC channel关闭时，会触发disconnect事件

exit
显示调用 process.exit()
Node.js事件循环数组中不再有额外的工作
这两种情况下，没有任何方法可以阻止事件循环的结束，一旦所有与exit事件绑定的监听器执行完成，Node.js的进程会终止

exit 事件监听器的回调函数，只有一个入参，process.exitCode
exit 事件监听器的毁掉函数，只允许包含同步操作，所有监听器的回调函数被调用后，任何在事件循环数组中排队的工作都会被强制丢弃，然后Node.js进程会立即结束。

message
如果Node.js的进程时由IPC channel的方式创建的，当子进程收到父进程的消息时，会触发'message'事件
message事件监听器的回调函数中被传递的参数如下
message-解析的JSON对象或primitive值
sendHandle-一个net.Socket或net.Server，或undefined

rejectionHandled
如果有Promise被rejected，并且此Promise在Node.js事件循环的下次轮询及之后期间，被绑定了一个错误处理器，会触发rejectionHandled事件
此事件监听器的回调函数使用Rejected的Promise引用
Promise对象应该已经在unhandleRejection事件触发时被处理，但是在被处理过程中获得了一个rejection处理器
对于Promise chain，没有概念表明在Promise chain的哪个地方，所有的rejections总是会被处理。

uncaughtException
如果JavaScript未捕获的异常

unhandledRejection

warning
name
message
stack

--trace-warnings 命令行选项可以让默认的console输出告警信息时

Signal Events
信号事件

process.abort()
--使Node.js进程立即结束

process.arch
--标识Node.js在其上运行的处理器架构的字符串 arm ia32 x64

process.argv--
返回一个数组，包含启动Node.js进程时的命令行参数，process.execPath

process.argv0--
保存Node.js启动时传入的argv[0]参数值的一份只读副本

process.channel--
如果Node.js进程是由IPC channel方式创建的

process.chdir(directory)
process.chdir()方法变更Node.js进程的当前工作目录

process.config
描述用于编译当前Node.js执行程序时涉及的配置项信息

target_defaults
cflags
default_configuration
defines
include_dirs
libraries

variable
host_arch
node_install_npm
node_prefix
node_shared_cares
node_shared_http_parser
node_shared_libuv
node_shared_zlib
node_use_dtrace
node_use_openss1
node_shared_openss1
strict_aliasing
target_arch
v8_use_snapshot

process.connected

process.cpuUsage([previousValue])
执行用户程序和系统程序的时间

process.cwd()
返回Node.js进程当前工作的目录

process.disconnect()

process.emitWarning(warning, options)

process.env--
返回一个包含用户环境信息的对象

TERM 'xterm-256color'
SHELL '/usr/local/bin/bash'
USER 'maciej'
PATH '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'
PWD 'Users/maciej'
EDITOR 'vim'
SHIVL '1'
HOME '/Users/maciej'
LOGNAME 'maciej'
_ '/usr/local/bin/node'

在process.env中新增一个属性，会将属性值转换为字符串
在Windows系统下，环境变量是不区分大小写的

process.execArgv--
返回当Node.js进程被启动时，Node.js特定的命令行选项，这些选项中不会包括Node.js的可执行脚本名称或者任何在脚本名称后面出现的选项

process.execPath--
返回启动Node.js进程的可执行文件所在的绝对路径

process.exit([code])
同步终止进程
在exit事件监听器都被调用了以后，才会终止进程

调用process.exit()会强制进程尽快结束，即使仍然有很多处于等待中的异步操作没有全部执行完成

process.exitCode
当进程正常结束，或通过process.exit()结束但未传递参数时，此数值标识进程结束的状态码

process.getegid()
--返回进程的有效数字标记的组身份

process.geteuid()
--返回进程的有效数字标记的用户身份

process.getgid()

process.getgroups()

process.getuid()

process.hrtime(time)

process.initgroups(user, extra_group)
读取etc/group文件，并且初始化组访问列表，该列表包括了用户所在的所有组。

process.kill(pid, signal)
将sianal发送给pid标识的进程，发送的信号可能是做一些与kill目标进程无关的事情

process.mainModule

process.memoryUsage()
返回Node.js进程的内存使用情况的对象
rss
heapTotal
heapUsed
external

process.nextTick(callback, ...args)
将callback添加到next tick队列，一旦当前事件轮询队列的任务全部完成，在next tick队列的callbacks会被依次调用
事件轮询随后的ticks调用，会在任何i/o事件之前运行

process.pid
--返回进程的PID

process.platform
--返回其操作系统平台 darwin freebsd linux sunos win32

process.release
--返回与当前发布相关的元数据对象
name
sourUrl
headerUrl
libUrl
lts

process.send(message, sendHandle, options, callback)

process.setegid(id)

process.seteuid(id)

process.setgid(id)

process.setgroups(groups)

process.setuid(id)

process.stderr

process.stdin

process.stdout

process.title

process.umask(mask)

process.uptime()
返回当前Node.js进程运行时间秒长

process.version

process.versions
http_parser
node
v8
uv
zlib
ares
modules
icu
openssl
unicode
cldr
tz

Exit Codes
1 未捕获异常
2 未被使用
3 内部JavaScript分析错误
4 内部JavaScript执行失败
5 致命错误
6 非函数的内部异常处理
7 内部异常处理运行时失败
8 未被使用
9 不可用参数
10 内部JavaScript运行时失败
12 不可用的调试参数
128 退出信号

（二十）、querystring（查询字符串）

querystring模块提供了一些实用函数，用于解析和格式化URL查询字符串
const querystring = require('quertstring')

querystring.escape(str)
对给定的str进行URL编码

querystring.parse(str, sep, eq, options)
str--要解析的URL查询字符串
sep--用于界定查询字符串中的键值对的子字符串，默认为 &
eq--用于界定查询字符串中的键与值的子字符串 默认为 =
options
decodeURIComponent 解码查询字符串的字符时使用的函数
maxKeys 要解析的键的最大数量 默认为1000

返回的对象不继承自JavaScript的Object类

查询字符串中的字符会被视为使用UTF-8编码，如果用其他字符编码，则需要指定decodeURIComponent

querystring.stringify(obj, sep, eq, options)
obj--要序列化成URL查询字符串的对象
options
encodeURIComponent

querystring.unescape(str)
该方法是提供给querystring.parse()使用的，通常不直接使用

（二十一）、readline（逐行读取）

用于从可读流读取数据，每次读取一行

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
})

rl.question('你认为Node.js中文网怎么样？', (answer) => {
    rl.close()
})
当调用该代码时，Node.js程序不会终止，直到readline.Interface被关闭，因为接口在等待input流中要被接受的数据

close--close()  end  CTRL-D CTRL-C
line--\r \n \r\n
pause--input流被暂停 input流不是暂停的接收到SIGCONT事件
resume

SIGCONT
SIGINT
SIGTSTP

rl.close()
rl.pause()
rl.prompt(preserveCursor)
rl.question(query, callback)
rl.resume()
rl.setPrompt(prompt)
rl.write(data, key)
readline.clearLine(stream, dir)
readline.clearScreenDown(stream)
readline.createInterface(options)
options--
input
output
completer
terminal
historySIze
prompt
crlfDelay
removeHistoryDuplicates

completer

readline.cursorTo(stream, x, y)

readline.emitKeypressEvents(stream, interface)

readline.moveCursor(stream, dx, dy)

（二十二）、repl（交互式解释器）

repl模块提供了一种 读取-求值-输出 循环的实现，

repl模块导出了repl.REPLServer类，当repl.REPLServer实例运行时，它接收用户输入的每一行，根据用户定义的解释函数解释这些输入，然后输出结果

.break
.clear
.exit
.help
.save
.load
.editor

_

eval
writer

REPLServer类 继承自 readline.Interface
repl.start()

exit
reset

replServer.defineCommand(keyword, cmd)

reolServer.displayPrompt()

repl.start(options)

prompt
input
output
terminal
eval
useColors
usrGlobal
ignoreUnfefined
writer
completer
replModel
breakEvalOnSigint


NODE_REPL_HISTORY

（二十三）、stream（流）

Stream在Node.js中时处理流数据的抽象接口，stream模块提供了基础的API，使用这些API可以很容易地来构建实现流接口的对象

Node.js提供了多种流对象，例如 HTTP请求 和 process.stdout 就都是流的实例

流可以是可读的，可写的，或是可读写的，所有的流都是EventEmitter的实例

Node.js中有四种基本的流类型

Readable--可读的流 如 fs.createReadStream
Writable--可写的流 如 fs.createWriteStream
Duplex--可读写的流 如 net.socket
Transform--在读写过程中可以修改和变换数据的Duplex流

所有使用Node.js API创建的流对象都只能操作String和buffer对象，但是，通过一些第三方流的实现，你依然能够处理其他类型的JavaScript值，这些流被认为是工作在"对象模式"
在创建流的实例时，可以通过objectMode选项使流的实例切换到对象模式，试图将已经存在的流切换到对象模式是不安全的

缓冲--
Writable和Readable流都会将数据存储到内部的缓存中，这些缓存可以通过响应的writable._writableState.getBuffer() readable._readableState.buffer
缓存的大小取决于传递给流构造函数的highWaterMark选项，对于普通的流，highWaterMark选项指定了总共的字节数，对于工作在对象模式的流，highWaterMark指定了对象的总数

stream.Writable类

close
drain
error
finish
pipe--在可读流上调用stream.pipe()方法，并在目标流向中添加当前可写流时，将会在可写流上触发pipe事件
unpipe--

writable.cork()--
writalbe.end(chunk, encoding, callback)
writable.setDefaultEncoding(encoding)

writable.uncork()
writable.write(chunk, encoding, callback)
writable.destroy(error)

可读流 是对提供数据的源头的抽象

readable._readableState.flowing null false true

stream.Readable

close
data
end
error
readable

readable.isPaused()
readable.pause()
readable.pipe(destination, options)

readable.read(size)
readable.resume()
readable.setEncoding(encoding)
readable.unpipe(destination)

readable.unshift(chunk)
readable.wrap(stream)

readable.destroy(error)
destroy the stream, and emit error. After this call, the transform  stream would release any internal resources. implementors should not override this method, but instead implement read._destroy. the default implementation of _destroy for Transform also emit 'close'

实现流的代码里面不应该出现调用 'public' 方法的地方，因为这些方法是给使用者使用的

new stream.Writable(options)
highWaterMark
decodeStrings
objectMode
write
writev
destroy
final

Errors While Writing

const { Writable } = require('stream')
const { StringDecoder } = require('string_decoder')

class StringWritable extends Writable {
    constructor(options) {
        super(options)
        const state = this._writableState;
        this._decoder = new StringDecoder(state.defauleEncoding)
        this.data = ''
    }
}










































（二十四）、string_decoder（字符串解码器）

string_decoder模块提供了一个API，用于把buffer对象编码成字符串

new StringDecoder('utf8')
decoder.write()

new StringDecoder(encoding)
stringDecoder.end(buffer)
stringDecoder.write(buffer)

（二十五）、timer（定时器）

timer模块暴露了一个全局的API，用于在某个未来时间段调用调度函数

基于Node.js事件循环 构建的

timeout.ref()
只要Timeout处于活动状态就要求Node.js事件循环不要退出

timeout.unref()
活动的Timeout对象不要求Node.js事件循环保持活动

setImmediate(callback, ...args)

（二十六）、tls（安全传输层）

tls模块是对安全传输层 TLS 及安全套接层 SSL 协议的实现，建立在OpenSSL的基础上
const tls = require('tls')


（二十七）、tty（终端）

tty.ReadStream

writeStream.cloumns
writeStream.rows

tty.isatty(fd)--给定的fd是否关联TTY

（二十八）、url（网址）

（二十七）、util（实用工具）

util.format()

（二十八）、v8（v8引擎）

（二十九）、vm（虚拟机）

分离的作用域上下文环境

（三十）、zlib（压缩）
























































</body>
</html>