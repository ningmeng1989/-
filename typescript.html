<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Typescript</title>
</head>
<body>

(一)、基础类型

数字，字符串，结构体，布尔值等

布尔值
let isDone: Boolean = false;

数字
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;

字符串
let name: string = 'bob';
let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${name}


I'll be ${age + 1} years old next month.`;

数组
let list: number[] = [1, 2, 3];

数组泛型
let list: Array<number> = [1, 2, 3];

</number>

元祖 Tuple
一个已知元素数量和类型的数组，各元素的类型不必相同

let x: [string, number];

x = ['hello', 10]

当访问一个已知索引的元素，会得到正确的类型

当访问一个越界的元素，会使用联合类型替代

枚举

使用枚举类型可以为一组数组赋予友好的名字
enum Color {Red, Green, Blue}
let c: Color = Color.Green;

默认情况下，从0开始为元素编号，也可以手动的指定成员的数值

enmu Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

或者全部都采用手动赋值

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;

枚举类型提供的一个遍历是你可以由枚举的值得到它的名字
let colorName: string = Color[2];

Any

有时候，我们不希望检查器对这些值进行检查而是直接让他们通过编译阶段的检查

let notSure: any = 4;

any允许你在编译时可选择地包含或移除类型检查

let notSure: any = 4;
notSure.ifItExists();
notSure.toFixed();

let prettySure: Object = 4;
prettySure.toFixed();

let list: any[] = [1, true, 'free'];

Void

当一个函数没有返回值时，其返回值类型是void
function warnUser(): void {
    alert('')
}

声明一个void类型的变量没有什么大用，只能为它赋予undefined和null

Null Undefined

默认情况下null和undefined是所有类型的子类型
--strictNullChecks null和undefined只能赋值给void和他们各自

Never
never类型表示的是那些永不存在的值的类型
never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头表达式的返回值类型

function error(message: string): never {
    throw new Error(message);
}

function fail() {
    return error('Something failed');
}

function infiniteLoop(): never {
    while (true) {}
}

类型断言

let someValue: any = 'this is a string';
let strLength: number = (<string>someValue).length;             </string>

JSX中只允许as语法断言
let someValue: any = 'this is a string';
let strLength: number= (someValue as string).length;

(二)、变量声明

var声明可以在它的函数，模块，命名空间或全局作用域内部任何位置被访问

不能在let语句之前访问它们

let 不能在一个作用域内重复声明同一个变量

let { a: newNumber1, b:newNumber2 } = o;

let { a, b }: { a: string, b: number } = o;

let bothPlus = [0, ...first, ...second, 5];

let search = { ...defaults, food: 'rich' }

出现在展开对象后面的属性会覆盖前面的属性

对象的展开，仅包含对象自身的可枚举属性

(三)、接口

TypeScript的核心原则之一是对值所具有的结构进行类型检查，鸭式辨型法 结构性子类型化
接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约

function printLabel(labelledObj: { label: string }) {
}
传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性呢是否存在

function viewFile (file) {

}

























































































































</body>
</html>