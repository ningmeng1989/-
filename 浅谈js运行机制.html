<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ECMAScript 6</title>
</head>
<body>

【一】、前言

    从开始接触js时，我们便知道js是单线程的，单线程，异步，同步，互调，阻塞等，在实际写js的时候，我们都会用到ajax，不管是原生的实现，还是jQuery等工具库实现，我们都知道，ajax可以实现局部刷新，并且在请求处理时，仍然可以相应用户的操作，比如点击事件，不是说js是单线程吗？这些是怎么是实现？

【二】、浏览器线程

js运行在浏览器中，是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。
浏览器是多线程的，除了js引擎线程，它还有：
1、UI渲染线程
2、浏览器事件触发线程
3、http请求线程
4、EventLoop轮询的处理线程
5、...

这些线程的作用：
UI线程用于渲染页面
js线程用于执行js任务
浏览器事件触发线程用于控制交互，相应用户
http线程用于处理请求，ajax是委托给浏览器新开一个http线程
EventLoop处理线程用于轮询消息队列

浏览器中的js任务：
执行js代码
对用户的输入（包含鼠标点击、键盘输入等等）做出反应
处理异步的网络请求

【三】、js单线程

单线程的含义是js只能在一个线程上运行，也就是说，js同时只能执行一个js任务，其他的任务则会排队等待执行
js是单线程的，并不代表js引擎线程只有一个，js引擎有多个线程，一个主线程，其他的后台配合主线程
多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦，js可以操作dom，影响渲染，所以js引擎线程的UI线程是互斥的，这也就解释了js执行时会阻塞页面的渲染

【四】、消息队列（任务队列）

JavaScript运行时，除了一个运行线程，引擎还提供了一个消息队列，里面是各种需要当前程序处理的消息，新的消息进入队列的时候，会自动排在队列的尾端。

消息和回调函数相互联系：

单线程意味着js任务需要排队，如果有一个任务出现大量的耗时操作，后面的任务得不到执行，任务的积累会导致页面的“假死”,这也是js编程一致在强调需要回避的“坑”

【五】、js任务

js任务分为2种：

同步任务
异步任务

它们的区别是：本段中的线程指的是js引擎主线程

同步任务：在主线程排队支持的任务，前一个任务执行完毕后，执行后一个任务，形成一个执行栈，线程是执行时在内存形成的空间为栈，进程形成堆结构，这是内存的结构，执行栈可以实现函数的层层调用。注意不要理解成同步代码进入栈中，按栈的出栈顺序来执行
异步任务：会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会

主线程执行的说明：

1、所有的同步任务都在主线程上执行，形成一个执行栈
2、主线程之外，还存在一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件
3、一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
4、主线程不断重复上面的第三步

执行栈中的代码（同步任务），总是在读取“任务队列”（异步任务）之前执行。

【六】、事件和回调函数

1、消息队列：队列是一个事件的队列，IO响应时，会往队列中添加一个消息，此时说明相关的异步代码到了执行的时机，可以进入主线程的执行栈了
2、主线程读取消息队列，可以读取到对应的事件
3、消息队列可以响应IO事件，还有用户产生的事件（比如点击鼠标，页面滚动），只要指定了回调函数，就会进入消息队列，等待EventLoop轮询线程处理，是否可以进入主线程的执行栈
4、消息和回调函数相关联系的含义：主线程读到消息，就会执行相应的回调函数，进入消息队列的消息，必须对应相应的回调函数，否则这个消息会被丢弃不会进入消息队列
5、消息队列是一个先进先出的队列结构，这就决定了它的执行顺序，先产生的消息会被主线程先读取，会不会执行则会先检查一下执行时间，因为存在setTimeout等定时任务，这类事件产生的消息进入到消息队列，被执行的时机取决于它在队列中的位置和执行时间有关。

【七】、EventLoop

主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又被称为EventLoop（事件循环）

简单说，浏览器的两个线程，一个负责程序本身的运行，称为“主线程”，另一个负责主线程与其他进程（主要是各种IO操作）通信，被称为“Event Loop线程”

由于js是运行在单线程上的，所有浏览器单独开启一个线程来处理事件消息的轮询，避免阻塞js的执行

异步代码的执行逻辑：
每当遇到I/O的时候，主线程就让EventLoop线程去通知相应的I/O程序，然后接着往后运行，所以不存在等待时间，等到I/O程序完成操作，EventLoop线程把消息添加到消息队列，主线程就调用事先设定的回调函数，完成整个任务。

JavaIO中包含了网络IO，我们通常把http请求归类为网络IO
js的ajax是new XMLHttpRequest()对象实现的，浏览器会新开一个线程来处理http请求，这就是ajax能够实现局部刷新的同时，还能响应用户交互的原因。

这也说明在处理IO时，浏览器通常会新开启IO线程，这是作者的推测

【八】、定时器

前面也提到了定时器，定时器是会进入消息队列，这也就和异步代码的执行逻辑一样了，它在消息队列的尾部添加一个消息，因此要等到同步任务和消息队列现有的任务都处理完，才会得到执行的机会，还要看定时器设置的时间是否到了才会执行




































































































</body>
</html>